<!DOCTYPE xsl:stylesheet [

    <!ENTITY mdash       "&#x2014;">
    <!ENTITY ndash       "&#x2013;">
    <!ENTITY hellip      "&#x2026;">

]>
<xsl:stylesheet version="3.0"
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xd="http://www.pnp-software.com/XSLTdoc"
    xmlns:f="urn:stylesheet-functions"
    exclude-result-prefixes="f xs xd">


    <xd:doc type="stylesheet">
        <xd:short>Utility templates and functions, used by tei2html</xd:short>
        <xd:detail>This stylesheet contains utility templates and functions, used by tei2html and tei2epub.</xd:detail>
        <xd:author>Jeroen Hellingman</xd:author>
        <xd:copyright>2017, Jeroen Hellingman</xd:copyright>
    </xd:doc>


    <xd:doc>
        <xd:short>Generate a stable id for a node.</xd:short>
        <xd:detail>
            <p>We want to generate ids that are slightly more stable than those generated by
            <code>generate-id()</code>. The general idea is to use an explicit id if that is present, and
            otherwise create an id based on the first ancestor node that does have an id. If,
            for example the third paragraph of a division with id '<code>ch2</code>' has no id of itself,
            we generate: "<code>ch2_p_3</code>" as an id. The second note in this division would receive
            the id "<code>ch2_note_2</code>".</p>

            <table>
                <tr><th>Language    </th><th>Safe ID syntax </th></tr>
                <tr><td>HTML:       </td><td><code>[A-Za-z][A-Za-z0-9_:.-]*</code></td></tr>
                <tr><td>CSS:        </td><td><code>-?[_a-zA-Z]+[_a-zA-Z0-9-]*</code></td></tr>
                <tr><td>Combined:   </td><td><code>[A-Za-z][A-Za-z0-9_-]*</code></td></tr>
            </table>
        </xd:detail>
        <xd:param name="node">The node for which the stable id is generated.</xd:param>
    </xd:doc>

    <xsl:function name="f:generate-stable-id" as="xs:string">
        <xsl:param name="node" as="node()"/>

        <xsl:variable name="base" select="$node/ancestor-or-self::*[@id][1]"/>
        <xsl:variable name="base" select="if ($base) then $base else ($node/ancestor-or-self::*)[1]"/>
        <xsl:variable name="baseid" select="if ($base/@id) then $base/@id else ''" as="xs:string"/>
        <xsl:variable name="name" select="local-name($node)" as="xs:string"/>
        <xsl:variable name="count" select="count($base//*[local-name() = $name] except $node/following::*[local-name() = $name])"/>
        <xsl:variable name="id" select="$baseid || '_' || $name || '_' || $count"/>

        <xsl:copy-of select="f:log-info('Generated ID: {1} from {2}-th [{3}] child of [{4}].', ($id, string($count), $name, local-name($base)))"/>

        <xsl:value-of select="$id"/>
    </xsl:function>


    <xd:doc>
        <xd:short>Generate an <code>id</code>-value.</xd:short>
        <xd:detail>
            <p>Generate an <code>id</code>-value for a node.</p>
            <p>The generated id will re-use the existing <code>id</code> attribute if present, or use the <code>generate-id()</code> function otherwise.
            Such generated id's will be prefixed with the letter 'x'</p>
        </xd:detail>
        <xd:param name="node" type="element()">The node for which the <code>id</code>-value is generated.</xd:param>
    </xd:doc>

    <xsl:function name="f:generate-id" as="xs:string">
        <xsl:param name="node" as="element()"/>
        <xsl:value-of select="if ($node/@id) then $node/@id else 'x' || generate-id($node)"/>
    </xsl:function>


    <xsl:function name="f:needs-id" as="xs:boolean">
        <xsl:param name="node" as="element()"/>

        <xsl:choose>
            <!-- Do we have a reference to it -->
            <xsl:when test="root($node)//ref[@target = $node/@id]"><xsl:value-of select="true()"/></xsl:when>
            <!-- Division that appears in a table of contents -->
            <xsl:when test="name($node) = ('div', 'div0', 'div1', 'div2', 'div3', 'div4', 'div5', 'div6') and root($node)//divGen[@type='toc']"><xsl:value-of select="true()"/></xsl:when>

            <xsl:otherwise><xsl:value-of select="false()"/></xsl:otherwise>
        </xsl:choose>

        <!-- Image that appears in a list of illustrations -->
        <!-- Correction that appears in a list of corrections -->
        <!-- External reference that appears in a list of external references -->
        <!-- Footnotes -->

    </xsl:function>


    <xd:doc>
        <xd:short>Generate an <code>id</code>-value.</xd:short>
        <xd:detail>
            <p>Generate an <code>id</code>-value for a node.</p>
            <p>The generated id will use <code>f:generate-id</code> and append the position.</p>
        </xd:detail>
        <xd:param name="node" type="element()">The node for which the <code>id</code>-value is generated.</xd:param>
        <xd:param name="position" type="xs:integer">A value appended after the generated <code>id</code>.</xd:param>
    </xd:doc>

    <xsl:function name="f:generate-nth-id" as="xs:string">
        <xsl:param name="node" as="element()"/>
        <xsl:param name="position" as="xs:integer"/>
        <xsl:value-of select="f:generate-id($node) || '-' || $position"/>
    </xsl:function>


    <xd:doc>
        <xd:short>Copy a node-tree while stripping al ids.</xd:short>
        <xd:detail>Copy a node-tree while stripping al ids. This allows us to use content from the source document multiple times,
        without having duplicate ids (which we normally copy from the source document, if present) in the output.</xd:detail>
    </xd:doc>

    <xsl:function name="f:copy-without-ids">
        <xsl:param name="nodes"/>
        <xsl:apply-templates select="$nodes" mode="copy-without-ids"/>
    </xsl:function>

    <xsl:template match="@id" mode="copy-without-ids"/>

    <xsl:template match="@*|node()" mode="copy-without-ids">
        <xsl:copy>
            <xsl:apply-templates select="@*|node()" mode="copy-without-ids"/>
        </xsl:copy>
    </xsl:template>


    <xd:doc>
        <xd:short>Copy a node-tree while prefixing all ids.</xd:short>
        <xd:detail>Copy a node-tree while prefixing al ids with a given prefix. This allows us to use content from the source document multiple times,
        without having duplicate ids (which we normally copy from the source document, if present) in the output.</xd:detail>
    </xd:doc>

    <xsl:function name="f:copy-with-id-prefix">
        <xsl:param name="nodes"/>
        <xsl:param name="id-prefix" as="xs:string"/>

        <xsl:apply-templates select="$nodes" mode="copy-with-id-prefix">
            <xsl:with-param name="id-prefix" select="$id-prefix" as="xs:string" tunnel="yes"/>
        </xsl:apply-templates>
    </xsl:function>

    <xsl:template match="@id" mode="copy-with-id-prefix">
        <xsl:param name="id-prefix" as="xs:string" tunnel="yes"/>
        <xsl:attribute name="id" select="$id-prefix || ."/>
    </xsl:template>

    <xsl:template match="@*|node()" mode="copy-with-id-prefix">
        <xsl:copy>
            <xsl:apply-templates select="@*|node()" mode="copy-with-id-prefix"/>
        </xsl:copy>
    </xsl:template>


    <!--====================================================================-->
    <!-- Close and (re-)open paragraphs -->

    <xd:doc>
        <xd:short>Close a <code>p</code>-element in the output.</xd:short>
        <xd:detail><p>To accommodate the differences between the TEI and HTML paragraph model,
        we sometimes need to close (and reopen) paragraphs, as various elements
        are not allowed inside <code>p</code>-elements in HTML.</p>

        <p>The following cases need to be taken into account:</p>

        <ul>
            <li>We use the variable <code>$p.element</code> but it is not set the value <code>'p'</code></li>
            <li>We are actually inside a <code>p</code> element.</li>
            <li>We do not locally override the variable <code>$p.element</code>, for example when we need to nest special elements
            in a <code>p</code> element (see template handle-paragraph in block.xsl).</li>
        </ul>

        </xd:detail>
    </xd:doc>

    <xsl:function name="f:needs-close-par" as="xs:boolean">
        <xsl:param name="element" as="element()"/>

        <xsl:variable name="output_p" select="$p.element = 'p'" as="xs:boolean"/>
        <xsl:variable name="parent_p" select="$element/parent::p or $element/parent::note" as="xs:boolean"/>
        <xsl:variable name="parent_does_not_contain_ditto" select="not($element/parent::p[.//ditto] or $element/parent::note[.//ditto])" as="xs:boolean"/>

        <xsl:value-of select="$output_p and $parent_p and $parent_does_not_contain_ditto"/>
        <!--<xsl:value-of select="false()"/>-->
    </xsl:function>

    <xsl:template name="closepar">
        <!-- insert </p> to close current paragraph as tables in paragraphs are illegal in HTML -->
        <xsl:if test="f:needs-close-par(.)">
            <xsl:text disable-output-escaping="yes">&lt;/p&gt;</xsl:text>
        </xsl:if>
    </xsl:template>


    <xd:doc>
        <xd:short>Re-open a <code>p</code>-element in the output.</xd:short>
        <xd:detail>Re-open a previously closed <code>p</code>-element in the output.
        This generates an extra <code>p</code>-element in the output.</xd:detail>
    </xd:doc>

    <xsl:template name="reopenpar">
        <xsl:if test="f:needs-close-par(.)">
            <xsl:text disable-output-escaping="yes">&lt;p&gt;</xsl:text>
        </xsl:if>
    </xsl:template>


    <xsl:function name="f:show-debug-tags">
        <xsl:param name="node" as="node()"/>

        <xsl:if test="f:is-set('debug')">
            <span class="showtags">
                <xsl:text>&lt;</xsl:text>
                <xsl:value-of select="name($node)"/>
                <xsl:if test="$node/@id">
                    <xsl:text> id='</xsl:text><xsl:value-of select="$node/@id"/><xsl:text>'</xsl:text>
                </xsl:if>
                <xsl:text>&gt;</xsl:text>
            </span>
        </xsl:if>
    </xsl:function>


    <!--====================================================================-->
    <!-- Language tagging -->

    <xd:doc>
        <xd:short>Determine the natural language used in the indicated node.</xd:short>
    </xd:doc>

    <xsl:function name="f:get-current-lang" as="xs:string">
        <xsl:param name="node" as="node()"/>
        <xsl:variable
            name="current-lang"
            select="($node/ancestor-or-self::*/@lang | $node/ancestor-or-self::*/@xml:lang)[last()]"/>
        <xsl:value-of select="if ($current-lang) then $current-lang else f:get-document-lang()"/>
    </xsl:function>


    <xd:doc>
        <xd:short>Determine the natural language indicated for the entire document.</xd:short>
    </xd:doc>

    <xsl:function name="f:get-document-lang" as="xs:string">
        <xsl:value-of select="$root/*[self::TEI.2 or self::TEI]/@lang | $root/*[self::TEI.2 or self::TEI]/@xml:lang"/>
    </xsl:function>


    <xd:doc>
        <xd:short>Generate a lang attribute.</xd:short>
        <xd:detail>Generate a lang attribute. Depending on the output method (HTML or XML),
        either the <code>lang</code> or the <code>xml:lang</code> attribute, or both, will
        be set on the output element if a lang attribute is present in the source.</xd:detail>
    </xd:doc>

    <xsl:function name="f:generate-lang-attribute" as="attribute()*">
        <xsl:param name="lang" as="xs:string?"/>

        <xsl:if test="$lang">
            <xsl:choose>
                <xsl:when test="$outputMethod = 'xhtml'">
                    <xsl:if test="f:is-html()">
                        <xsl:attribute name="lang" select="f:fix-lang($lang)"/>
                    </xsl:if>
                    <xsl:attribute name="xml:lang" select="f:fix-lang($lang)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="lang" select="f:fix-lang($lang)"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:function>


    <xd:doc>
        <xd:short>Normalize a language attribute.</xd:short>
        <xd:detail>Normalize language attributes used in the output to match
        valid language codes (see https://tools.ietf.org/html/rfc5646).</xd:detail>
    </xd:doc>

    <xsl:function name="f:fix-lang" as="xs:string">
        <xsl:param name="lang" as="xs:string"/>

        <xsl:choose>
            <!-- Strip endings with -x-..., such as in la-x-bio -->
            <xsl:when test="matches($lang, '^[a-z]{2}-x-')">
                <xsl:value-of select="substring($lang, 1, 2)"/>
            </xsl:when>
            <!-- Strip endings with -1900, such as in nl-1900 -->
            <xsl:when test="matches($lang, '^[a-z]{2}-\d{4}')">
                <xsl:value-of select="substring($lang, 1, 2)"/>
            </xsl:when>
            <!-- Fix case of language + country code (e.g. nl-BE) -->
            <xsl:when test="matches($lang, '^[a-z]{2}-[A-Za-z]{2}$')">
                <xsl:value-of select="substring($lang, 1, 3) || upper-case(substring($lang, 4, 2))"/>
            </xsl:when>
            <!-- Avoid 2-letter language + 4-letter script code, if in pg-compliant mode -->
            <xsl:when test="f:is-set('pg.compliant') and matches($lang, '^(zh-Hant|zh-Hans)$')">
                <xsl:value-of select="'zh'"/>
            </xsl:when>
            <xsl:when test="f:is-set('pg.compliant') and matches($lang, '^[a-z]{2}-[A-Za-z]{4}$')">
                <!-- Use 'und' to prevent browsers from automatically selecting the font for the default script -->
                <xsl:value-of select="'und'"/>
            </xsl:when>
            <!-- Fix case of 2-letter language + script code (e.g. zh-Latn) -->
            <xsl:when test="matches($lang, '^[a-z]{2}-[A-Za-z]{4}$')">
                <xsl:value-of select="substring($lang, 1, 3) || upper-case(substring($lang, 4, 1)) || lower-case(substring($lang, 5, 3))"/>
            </xsl:when>
            <!-- Strip script code of 3-letter language + script code, if in pg-compliant mode -->
            <xsl:when test="f:is-set('pg.compliant') and matches($lang, '^[a-z]{3}-[A-Za-z]{4}$')">
                <xsl:value-of select="substring($lang, 1, 3)"/>
            </xsl:when>
            <!-- Fix case of 3-letter language + script code (e.g. grc-Latn) -->
            <xsl:when test="matches($lang, '^[a-z]{3}-[A-Za-z]{4}$')">
                <xsl:value-of select="substring($lang, 1, 4) || upper-case(substring($lang, 5, 1)) || lower-case(substring($lang, 6, 3))"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$lang"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>


    <!--====================================================================-->
    <!-- Shortcut for both id and language tagging -->

    <xd:doc>
        <xd:short>Generate both a lang and an id attribute.</xd:short>
    </xd:doc>

    <xsl:function name="f:set-lang-id-attributes" as="attribute()*">
        <xsl:param name="node" as="element()"/>

        <xsl:attribute name="id" select="f:generate-id($node)"/>
        <xsl:copy-of select="f:generate-lang-attribute($node/@lang)"/>
    </xsl:function>


    <xd:doc>
        <xd:short>Determine a node is a division.</xd:short>
    </xd:doc>

    <xsl:function name="f:is-division" as="xs:boolean">
        <xsl:param name="node"/>
        <xsl:sequence select="local-name($node) = ('div', 'div0', 'div1', 'div2', 'div3', 'div4', 'div5', 'div6')"/>
    </xsl:function>


    <xd:doc>
        <xd:short>Determine a node is a line-group.</xd:short>
    </xd:doc>

    <xsl:function name="f:is-line-group" as="xs:boolean">
        <xsl:param name="node"/>
        <xsl:sequence select="local-name($node) = 'lg'"/>
    </xsl:function>


    <!--====================================================================-->
    <!-- Generate labels for heads in the correct language -->

    <xd:doc>
        <xd:short>Translate the <code>type</code>-attribute of a division.</xd:short>
        <xd:detail>
            <p>Translate the <code>type</code>-attribute of a division to a string in the currently active language.</p>
        </xd:detail>
        <xd:param name="type" type="string">The value of the <code>type</code>-attribute.</xd:param>
    </xd:doc>

    <xsl:function name="f:translate-div-type" as="xs:string">
        <xsl:param name="type" as="xs:string"/>
        <xsl:variable name="type" select="lower-case($type)" as="xs:string"/>

        <xsl:choose>
            <xsl:when test="$type=''"><xsl:value-of select="''"/></xsl:when>
            <xsl:when test="$type='appendix'"><xsl:value-of select="f:message('msgAppendix')"/></xsl:when>
            <xsl:when test="$type='chapter'"><xsl:value-of select="f:message('msgChapter')"/></xsl:when>
            <xsl:when test="$type='part'"><xsl:value-of select="f:message('msgPart')"/></xsl:when>
            <xsl:when test="$type='book'"><xsl:value-of select="f:message('msgBook')"/></xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="f:log-warning('Division type: {1} not understood.', ($type))"/>
                <xsl:value-of select="''"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>


    <xd:doc>
        <xd:short>Determine the level of the division (either by counting its parents or looking at its name).</xd:short>
    </xd:doc>

    <xsl:function name="f:div-level" as="xs:integer">
        <xsl:param name="div" as="node()"/>

        <xsl:choose>
            <xsl:when test="local-name($div) = 'div'">
                <xsl:choose>
                    <xsl:when test="$div/ancestor::q">
                        <xsl:value-of select="count($div/ancestor::div[ancestor::q])"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="count($div/ancestor::div) + 1"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="local-name($div) = ('div0', 'div1', 'div2', 'div3', 'div4', 'div5', 'div6')">
                <xsl:choose>
                    <xsl:when test="$div/ancestor::q">
                        <xsl:value-of select="count($div/ancestor::*[self::div0 or self::div1 or self::div2 or self::div3 or self::div4 or self::div5 or self::div6][ancestor::q])"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="count($div/ancestor::*[self::div0 or self::div1 or self::div2 or self::div3 or self::div4 or self::div5 or self::div6]) + 1"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="f:log-error('Node {1} is not a division.', (local-name($div)))"/>
                <xsl:value-of select="1"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>


    <xd:doc>
        <xd:short>List of contributor roles and related OPF-codes and message ids.</xd:short>
        <xd:detail>
            <p>The list used was taken from the OPF Standard, 2.0, section 2.2.6
            [https://www.openebook.org/2007/opf/OPF_2.0_final_spec.html], which in turn was derived from the
            MARC Code List for Relators [https://www.loc.gov/marc/relators/relaterm.html] and extended.</p>
        </xd:detail>
    </xd:doc>

    <xsl:variable name="contributorRoles">
        <roles>
            <role code="adp" message="msgAdaptor">Adaptor</role>
            <role code="aft" message="msgAuthorOfAfterword">Author of afterword</role>
            <role code="aft" message="msgAuthorOfColophon">Author of colophon</role>
            <role code="aft" message="msgAuthorOfPostface">Author of postface</role>
            <role code="ann" message="msgAnnotator">Annotator</role>
            <role code="ant" message="msgBibliographicAntecedent">Bibliographic antecedent</role>
            <role code="aqt" message="msgAuthorInQuotations">Author in quotations</role>
            <role code="aqt" message="msgAuthorInTextExtracts">Author in text extracts</role>
            <role code="arr" message="msgArranger">Arranger</role>
            <role code="art" message="msgArtist">Artist</role>
            <role code="asn" message="msgAssociatedName">Associated name</role>
            <role code="aui" message="msgAuthorOfForeword">Author of foreword</role>
            <role code="aui" message="msgAuthorOfIntroduction">Author of introduction</role>
            <role code="aui" message="msgAuthorOfPreface">Author of preface</role>
            <role code="aut" message="msgAuthor">Author</role>
            <role code="bkp" message="msgBookProducer">Book producer</role>
            <role code="clb" message="msgCollaborator">Collaborator</role>
            <role code="clb" message="msgContributor">Contributor</role>
            <role code="cmm" message="msgCommentator">Commentator</role>
            <role code="dsr" message="msgDesigner">Designer</role>
            <role code="edt" message="msgEditor">Editor</role>
            <role code="egr" message="msgEngraver">Engraver</role>
            <role code="ill" message="msgIllustrator">Illustrator</role>
            <role code="ill" message="msgIllustrator">Illustration</role>
            <role code="ill" message="msgIllustrator">Illustrations</role>
            <role code="lyr" message="msgLyricist">Lyricist</role>
            <role code="mdc" message="msgMetadataContact">Metadata contact</role>
            <role code="mus" message="msgMusician">Musician</role>
            <role code="nrt" message="msgNarrator">Narrator</role>
            <role code="oth" message="msgOther">Other</role>
            <role code="pht" message="msgPhotographer">Photographer</role>
            <role code="prt" message="msgPrinter">Printer</role>
            <role code="red" message="msgRedactor">Redactor</role>
            <role code="rev" message="msgReviewer">Reviewer</role>
            <role code="spn" message="msgSponsor">Sponsor</role>
            <role code="ths" message="msgThesisAdvisor">Thesis advisor</role>
            <role code="trc" message="msgTranscriber">Transcriber</role>
            <role code="trc" message="msgTranscriber">Transcription</role>
            <role code="trl" message="msgTranslator">Translation</role>
            <role code="trl" message="msgTranslator">Translator</role>
        </roles>
    </xsl:variable>

    <xsl:function name="f:translate-resp" as="xs:string">
        <xsl:param name="resp" as="xs:string"/>

        <xsl:variable name="message" select="$contributorRoles//*[.=$resp]/@message"/>
        <xsl:copy-of select="f:log-debug('Translating contributor role: {1} to {2}', ($resp, $message))"/>
        <xsl:value-of select="if ($message) then f:message($message) else f:message('msgUnknown')"/>
    </xsl:function>

    <xsl:function name="f:translate-resp-code" as="xs:string">
        <xsl:param name="resp" as="xs:string"/>

        <xsl:variable name="code" select="$contributorRoles//*[.=$resp]/@code"/>
        <xsl:copy-of select="f:log-debug('Translating contributor role: {1} to {2}', ($resp, $code))"/>
        <xsl:value-of select="if ($code) then $code else 'oth'"/>
    </xsl:function>


    <xd:short>MARC code list for relators.</xd:short>
    <xd:detail>
        <p>Derived from the MARC Code List for Relators [https://www.loc.gov/marc/relators/relaterm.html].</p>
    </xd:detail>

    <xsl:variable name="relators">
        <relators>
            <relator code="abr" message="msgAbridger">abridger</relator>
            <relator code="act" message="msgActor">actor</relator>
            <relator code="adp" message="msgAdapter">adapter</relator>
            <relator code="rcp" message="msgAddressee">addressee</relator>
            <relator code="anl" message="msgAnalyst">analyst</relator>
            <relator code="anm" message="msgAnimator">animator</relator>
            <relator code="ann" message="msgAnnotator">annotator</relator>
            <relator code="anc" message="msgAnnouncer">announcer</relator>
            <relator code="apl" message="msgAppellant">appellant</relator>
            <relator code="ape" message="msgAppellee">appellee</relator>
            <relator code="app" message="msgApplicant">applicant</relator>
            <relator code="arc" message="msgArchitect">architect</relator>
            <relator code="arr" message="msgArranger">arranger</relator>
            <relator code="acp" message="msgArtCopyist">art copyist</relator>
            <relator code="adi" message="msgArtDirector">art director</relator>
            <relator code="art" message="msgArtist">artist</relator>
            <relator code="ard" message="msgArtistic director">artistic director</relator>
            <relator code="asg" message="msgAssignee">assignee</relator>
            <relator code="asn" message="msgAssociatedName">associated name</relator>
            <relator code="att" message="msgAttributedName">attributed name</relator>
            <relator code="auc" message="msgAuctioneer">auctioneer</relator>
            <relator code="aue" message="msgAudioEngineer">audio engineer</relator>
            <relator code="aup" message="msgAudioProducer">audio producer</relator>
            <relator code="aut" message="msgAuthor">author</relator>
            <relator code="aqt" message="msgAuthorInQuotations">author in quotations or text abstracts</relator>
            <relator code="aft" message="msgAuthorOfAfterword">author of afterword, colophon, etc.</relator>
            <relator code="aud" message="msgAuthorOfDialog">author of dialog</relator>
            <relator code="aui" message="msgAuthorOfIntroduction">author of introduction, etc.</relator>
            <relator code="ato" message="msgAutographer">autographer</relator>
            <relator code="ant" message="msgBibliographicAntecedent">bibliographic antecedent</relator>
            <relator code="bnd" message="msgBinder">binder</relator>
            <relator code="bdd" message="msgBindingDesigner">binding designer</relator>
            <relator code="blw" message="msgBlurbWriter">blurb writer</relator>
            <relator code="bka" message="msgBookArtist">book artist</relator>
            <relator code="bkd" message="msgBookDesigner">book designer</relator>
            <relator code="bkp" message="msgBookProducer">book producer</relator>
            <relator code="bjd" message="msgBookjacketDesigner">bookjacket designer</relator>
            <relator code="bpd" message="msgBookplateDesigner">bookplate designer</relator>
            <relator code="bsl" message="msgBookseller">bookseller</relator>
            <relator code="brl" message="msgBrailleEmbosser">braille embosser</relator>
            <relator code="brd" message="msgBroadcaster">broadcaster</relator>
            <relator code="cll" message="msgCalligrapher">calligrapher</relator>
            <relator code="cop" message="msgCameraOperator">camera operator</relator>
            <relator code="ctg" message="msgCartographer">cartographer</relator>
            <relator code="cas" message="msgCaster">caster</relator>
            <relator code="cad" message="msgCastingDirector">casting director</relator>
            <relator code="cns" message="msgCensor">censor</relator>
            <relator code="chr" message="msgChoreographer">choreographer</relator>
            <relator code="cng" message="msgCinematographer">cinematographer</relator>
            <relator code="cli" message="msgClient">client</relator>
            <relator code="cor" message="msgCollectionRegistrar">collection registrar</relator>
            <relator code="col" message="msgCollector">collector</relator>
            <relator code="clt" message="msgCollotyper">collotyper</relator>
            <relator code="clr" message="msgColorist">colorist</relator>
            <relator code="cmm" message="msgCommentator">commentator</relator>
            <relator code="cwt" message="msgCommentatorForWrittenText">commentator for written text</relator>
            <relator code="com" message="msgCompiler">compiler</relator>
            <relator code="cpl" message="msgComplainant">complainant</relator>
            <relator code="cpt" message="msgComplainantAppellant">complainant-appellant</relator>
            <relator code="cpe" message="msgComplainantAppellee">complainant-appellee</relator>
            <relator code="cmp" message="msgComposer">composer</relator>
            <relator code="cmt" message="msgCompositor">compositor</relator>
            <relator code="ccp" message="msgConceptor">conceptor</relator>
            <relator code="cnd" message="msgConductor">conductor</relator>
            <relator code="con" message="msgConservator">conservator</relator>
            <relator code="csl" message="msgConsultant">consultant</relator>
            <relator code="csp" message="msgConsultantToAProject">consultant to a project</relator>
            <relator code="cos" message="msgContestant">contestant</relator>
            <relator code="cot" message="msgContestantAppellant">contestant-appellant</relator>
            <relator code="coe" message="msgContestantAppellee">contestant-appellee</relator>
            <relator code="cts" message="msgContestee">contestee</relator>
            <relator code="ctt" message="msgContesteeAppellant">contestee-appellant</relator>
            <relator code="cte" message="msgContesteeAppellee">contestee-appellee</relator>
            <relator code="ctr" message="msgContractor">contractor</relator>
            <relator code="ctb" message="msgContributor">contributor</relator>
            <relator code="cpc" message="msgCopyrightClaimant">copyright claimant</relator>
            <relator code="cph" message="msgCopyrightHolder">copyright holder</relator>
            <relator code="crr" message="msgCorrector">corrector</relator>
            <relator code="crp" message="msgCorrespondent">correspondent</relator>
            <relator code="cst" message="msgCostumeDesigner">costume designer</relator>
            <relator code="cou" message="msgCourtGoverned">court governed</relator>
            <relator code="crt" message="msgCourtReporter">court reporter</relator>
            <relator code="cov" message="msgCoverDesigner">cover designer</relator>
            <relator code="cre" message="msgCreator">creator</relator>
            <relator code="cur" message="msgCurator">curator</relator>
            <relator code="dnc" message="msgDancer">dancer</relator>
            <relator code="dtc" message="msgDataContributor">data contributor</relator>
            <relator code="dtm" message="msgDataManager">data manager</relator>
            <relator code="dte" message="msgDedicatee">dedicatee</relator>
            <relator code="dto" message="msgDedicator">dedicator</relator>
            <relator code="dfd" message="msgDefendant">defendant</relator>
            <relator code="dft" message="msgDefendantAppellant">defendant-appellant</relator>
            <relator code="dfe" message="msgDefendantAppellee">defendant-appellee</relator>
            <relator code="dgc" message="msgDegreeCommitteeMember">degree committee member</relator>
            <relator code="dgg" message="msgDegreeGrantingInstitution">degree granting institution</relator>
            <relator code="dgs" message="msgDegreeSupervisor">degree supervisor</relator>
            <relator code="dln" message="msgDelineator">delineator</relator>
            <relator code="dpc" message="msgDepicted">depicted</relator>
            <relator code="dpt" message="msgDepositor">depositor</relator>
            <relator code="dsr" message="msgDesigner">designer</relator>
            <relator code="drt" message="msgDirector">director</relator>
            <relator code="dis" message="msgDissertant">dissertant</relator>
            <relator code="dbp" message="msgDistributionPlace">distribution place</relator>
            <relator code="dst" message="msgDistributor">distributor</relator>
            <relator code="djo" message="msgDj">dj</relator>
            <relator code="dnr" message="msgDonor">donor</relator>
            <relator code="drm" message="msgDraftsman">draftsman</relator>
            <relator code="dbd" message="msgDubbingDirector">dubbing director</relator>
            <relator code="dub" message="msgDubiousAuthor">dubious author</relator>
            <relator code="edt" message="msgEditor">editor</relator>
            <relator code="edc" message="msgEditorOfCompilation">editor of compilation</relator>
            <relator code="edm" message="msgEditorOfMovingImageWork">editor of moving image work</relator>
            <relator code="edd" message="msgEditorialDirector">editorial director</relator>
            <relator code="elg" message="msgElectrician">electrician</relator>
            <relator code="elt" message="msgElectrotyper">electrotyper</relator>
            <relator code="enj" message="msgEnactingJurisdiction">enacting jurisdiction</relator>
            <relator code="eng" message="msgEngineer">engineer</relator>
            <relator code="egr" message="msgEngraver">engraver</relator>
            <relator code="etr" message="msgEtcher">etcher</relator>
            <relator code="evp" message="msgEventPlace">event place</relator>
            <relator code="exp" message="msgExpert">expert</relator>
            <relator code="fac" message="msgFacsimilist">facsimilist</relator>
            <relator code="fld" message="msgFieldDirector">field director</relator>
            <relator code="fmd" message="msgFilmDirector">film director</relator>
            <relator code="fds" message="msgFilmDistributor">film distributor</relator>
            <relator code="flm" message="msgFilmEditor">film editor</relator>
            <relator code="fmp" message="msgFilmProducer">film producer</relator>
            <relator code="fmk" message="msgFilmmaker">filmmaker</relator>
            <relator code="fpy" message="msgFirstParty">first party</relator>
            <relator code="frg" message="msgForger">forger</relator>
            <relator code="fmo" message="msgFormerOwner">former owner</relator>
            <relator code="fon" message="msgFounder">founder</relator>
            <relator code="fnd" message="msgFunder">funder</relator>
            <relator code="gdv" message="msgGameDeveloper">game developer</relator>
            <relator code="gis" message="msgGeographicInformationSpecialist">geographic information specialist</relator>
            <relator code="hnr" message="msgHonoree">honoree</relator>
            <relator code="hst" message="msgHost">host</relator>
            <relator code="his" message="msgHost institution">host institution</relator>
            <relator code="ilu" message="msgIlluminator">illuminator</relator>
            <relator code="ill" message="msgIllustrator">illustrator</relator>
            <relator code="ins" message="msgInscriber">inscriber</relator>
            <relator code="itr" message="msgInstrumentalist">instrumentalist</relator>
            <relator code="ive" message="msgInterviewee">interviewee</relator>
            <relator code="ivr" message="msgInterviewer">interviewer</relator>
            <relator code="inv" message="msgInventor">inventor</relator>
            <relator code="isb" message="msgIssuingBody">issuing body</relator>
            <relator code="jud" message="msgJudge">judge</relator>
            <relator code="jug" message="msgJurisdictionGoverned">jurisdiction governed</relator>
            <relator code="lbr" message="msgLaboratory">laboratory</relator>
            <relator code="ldr" message="msgLaboratoryDirector">laboratory director</relator>
            <relator code="lsa" message="msgLandscapeArchitect">landscape architect</relator>
            <relator code="led" message="msgLead">lead</relator>
            <relator code="len" message="msgLender">lender</relator>
            <relator code="ltr" message="msgLetterer">letterer</relator>
            <relator code="lil" message="msgLibelant">libelant</relator>
            <relator code="lit" message="msgLibelantAppellant">libelant-appellant</relator>
            <relator code="lie" message="msgLibelantAppellee">libelant-appellee</relator>
            <relator code="lel" message="msgLibelee">libelee</relator>
            <relator code="let" message="msgLibeleeAppellant">libelee-appellant</relator>
            <relator code="lee" message="msgLibeleeAppellee">libelee-appellee</relator>
            <relator code="lbt" message="msgLibrettist">librettist</relator>
            <relator code="lse" message="msgLicensee">licensee</relator>
            <relator code="lso" message="msgLicensor">licensor</relator>
            <relator code="lgd" message="msgLightingDesigner">lighting designer</relator>
            <relator code="ltg" message="msgLithographer">lithographer</relator>
            <relator code="lyr" message="msgLyricist">lyricist</relator>
            <relator code="mka" message="msgMakeupArtist">makeup artist</relator>
            <relator code="mfp" message="msgManufacturePlace">manufacture place</relator>
            <relator code="mfr" message="msgManufacturer">manufacturer</relator>
            <relator code="mrb" message="msgMarbler">marbler</relator>
            <relator code="mrk" message="msgMarkupEditor">markup editor</relator>
            <relator code="med" message="msgMedium">medium</relator>
            <relator code="mdc" message="msgMetadataContact">metadata contact</relator>
            <relator code="mte" message="msgMetalEngraver">metal-engraver</relator>
            <relator code="mtk" message="msgMinuteTaker">minute taker</relator>
            <relator code="mxe" message="msgMixingEngineer">mixing engineer</relator>
            <relator code="mod" message="msgModerator">moderator</relator>
            <relator code="mon" message="msgMonitor">monitor</relator>
            <relator code="mcp" message="msgMusicCopyist">music copyist</relator>
            <relator code="mup" message="msgMusicProgrammer">music programmer</relator>
            <relator code="msd" message="msgMusicalDirector">musical director</relator>
            <relator code="mus" message="msgMusician">musician</relator>
            <relator code="nrt" message="msgNarrator">narrator</relator>
            <relator code="nan" message="msgNewsAnchor">news anchor</relator>
            <relator code="onp" message="msgOnscreenParticipant">onscreen participant</relator>
            <relator code="osp" message="msgOnscreenPresenter">onscreen presenter</relator>
            <relator code="opn" message="msgOpponent">opponent</relator>
            <relator code="orm" message="msgOrganizer">organizer</relator>
            <relator code="org" message="msgOriginator">originator</relator>
            <relator code="oth" message="msgOther">other</relator>
            <relator code="own" message="msgOwner">owner</relator>
            <relator code="pan" message="msgPanelist">panelist</relator>
            <relator code="ppm" message="msgPapermaker">papermaker</relator>
            <relator code="pta" message="msgPatentApplicant">patent applicant</relator>
            <relator code="pth" message="msgPatentHolder">patent holder</relator>
            <relator code="pat" message="msgPatron">patron</relator>
            <relator code="prf" message="msgPerformer">performer</relator>
            <relator code="pma" message="msgPermittingAgency">permitting agency</relator>
            <relator code="pht" message="msgPhotographer">photographer</relator>
            <relator code="pad" message="msgPlaceOfAddress">place of address</relator>
            <relator code="ptf" message="msgPlaintiff">plaintiff</relator>
            <relator code="ptt" message="msgPlaintiffAppellant">plaintiff-appellant</relator>
            <relator code="pte" message="msgPlaintiffAppellee">plaintiff-appellee</relator>
            <relator code="plt" message="msgPlatemaker">platemaker</relator>
            <relator code="pra" message="msgPraeses">praeses</relator>
            <relator code="pre" message="msgPresenter">presenter</relator>
            <relator code="prt" message="msgPrinter">printer</relator>
            <relator code="pop" message="msgPrinterOfPlates">printer of plates</relator>
            <relator code="prm" message="msgPrintmaker">printmaker</relator>
            <relator code="prc" message="msgProcessContact">process contact</relator>
            <relator code="pro" message="msgProducer">producer</relator>
            <relator code="prn" message="msgProductionCompany">production company</relator>
            <relator code="prs" message="msgProductionDesigner">production designer</relator>
            <relator code="pmn" message="msgProductionManager">production manager</relator>
            <relator code="prd" message="msgProductionPersonnel">production personnel</relator>
            <relator code="prp" message="msgProductionPlace">production place</relator>
            <relator code="prg" message="msgProgrammer">programmer</relator>
            <relator code="pdr" message="msgProjectDirector">project director</relator>
            <relator code="pfr" message="msgProofreader">proofreader</relator>
            <relator code="prv" message="msgProvider">provider</relator>
            <relator code="pup" message="msgPublicationPlace">publication place</relator>
            <relator code="pbl" message="msgPublisher">publisher</relator>
            <relator code="pbd" message="msgPublishingDirector">publishing director</relator>
            <relator code="ppt" message="msgPuppeteer">puppeteer</relator>
            <relator code="rdd" message="msgRadioDirector">radio director</relator>
            <relator code="rpc" message="msgRadioProducer">radio producer</relator>
            <relator code="rap" message="msgRapporteur">rapporteur</relator>
            <relator code="rce" message="msgRecordingEngineer">recording engineer</relator>
            <relator code="rcd" message="msgRecordist">recordist</relator>
            <relator code="red" message="msgRedactor">redactor</relator>
            <relator code="rxa" message="msgRemixArtist">remix artist</relator>
            <relator code="ren" message="msgRenderer">renderer</relator>
            <relator code="rpt" message="msgReporter">reporter</relator>
            <relator code="rps" message="msgRepository">repository</relator>
            <relator code="rth" message="msgResearchTeamHead">research team head</relator>
            <relator code="rtm" message="msgResearchTeamMember">research team member</relator>
            <relator code="res" message="msgResearcher">researcher</relator>
            <relator code="rsp" message="msgRespondent">respondent</relator>
            <relator code="rst" message="msgRespondentAppellant">respondent-appellant</relator>
            <relator code="rse" message="msgRespondentAppellee">respondent-appellee</relator>
            <relator code="rpy" message="msgResponsibleParty">responsible party</relator>
            <relator code="rsg" message="msgRestager">restager</relator>
            <relator code="rsr" message="msgRestorationist">restorationist</relator>
            <relator code="rev" message="msgReviewer">reviewer</relator>
            <relator code="rbr" message="msgRubricator">rubricator</relator>
            <relator code="sce" message="msgScenarist">scenarist</relator>
            <relator code="sad" message="msgScientificAdvisor">scientific advisor</relator>
            <relator code="aus" message="msgScreenwriter">screenwriter</relator>
            <relator code="scr" message="msgScribe">scribe</relator>
            <relator code="scl" message="msgSculptor">sculptor</relator>
            <relator code="spy" message="msgSecondParty">second party</relator>
            <relator code="sec" message="msgSecretary">secretary</relator>
            <relator code="sll" message="msgSeller">seller</relator>
            <relator code="std" message="msgSetDesigner">set designer</relator>
            <relator code="stg" message="msgSetting">setting</relator>
            <relator code="sgn" message="msgSigner">signer</relator>
            <relator code="sng" message="msgSinger">singer</relator>
            <relator code="swd" message="msgSoftwareDeveloper">software developer</relator>
            <relator code="sds" message="msgSoundDesigner">sound designer</relator>
            <relator code="sde" message="msgSoundEngineer">sound engineer</relator>
            <relator code="spk" message="msgSpeaker">speaker</relator>
            <relator code="sfx" message="msgSpecialEffectsProvider">special effects provider</relator>
            <relator code="spn" message="msgSponsor">sponsor</relator>
            <relator code="sgd" message="msgStageDirector">stage director</relator>
            <relator code="stm" message="msgStageManager">stage manager</relator>
            <relator code="stn" message="msgStandardsBody">standards body</relator>
            <relator code="str" message="msgStereotyper">stereotyper</relator>
            <relator code="stl" message="msgStoryteller">storyteller</relator>
            <relator code="sht" message="msgSupportingHost">supporting host</relator>
            <relator code="srv" message="msgSurveyor">surveyor</relator>
            <relator code="tch" message="msgTeacher">teacher</relator>
            <relator code="tad" message="msgTechnicalAdvisor">technical advisor</relator>
            <relator code="tcd" message="msgTechnicalDirector">technical director</relator>
            <relator code="tld" message="msgTelevisionDirector">television director</relator>
            <relator code="tlg" message="msgTelevisionGuest">television guest</relator>
            <relator code="tlh" message="msgTelevisionHost">television host</relator>
            <relator code="tlp" message="msgTelevisionProducer">television producer</relator>
            <relator code="tau" message="msgTelevisionWriter">television writer</relator>
            <relator code="ths" message="msgThesisAdvisor">thesis advisor</relator>
            <relator code="trc" message="msgTranscriber">transcriber</relator>
            <relator code="trl" message="msgTranslator">translator</relator>
            <relator code="tyd" message="msgTypeDesigner">type designer</relator>
            <relator code="tyg" message="msgTypographer">typographer</relator>
            <relator code="uvp" message="msgUniversityPlace">university place</relator>
            <relator code="vdg" message="msgVideographer">videographer</relator>
            <relator code="vfx" message="msgVisualEffectsProvider">visual effects provider</relator>
            <relator code="vac" message="msgVoiceActor">voice actor</relator>
            <relator code="wit" message="msgWitness">witness</relator>
            <relator code="wde" message="msgWoodEngraver">wood engraver</relator>
            <relator code="wdc" message="msgWoodcutter">woodcutter</relator>
            <relator code="wam" message="msgWriterOfAccompanying material">writer of accompanying material</relator>
            <relator code="wac" message="msgWriterOfAddedCommentary">writer of added commentary</relator>
            <relator code="wal" message="msgWriterOfAddedLyrics">writer of added lyrics</relator>
            <relator code="wat" message="msgWriterOfAddedText">writer of added text</relator>
            <relator code="wfs" message="msgWriterOfFilmStory">writer of film story</relator>
            <relator code="wft" message="msgWriterOfIntertitles">writer of intertitles</relator>
            <relator code="win" message="msgWriterOfIntroduction">writer of introduction</relator>
            <relator code="wpr" message="msgWriterOfPreface">writer of preface</relator>
            <relator code="wst" message="msgWriterOfSupplementaryTextualContent">writer of supplementary textual content</relator>
            <relator code="wts" message="msgWriterOfTelevisionStory">writer of television story</relator>
        </relators>
    </xsl:variable>


    <xd:doc>
        <xd:short>Strip all diacritics from a string.</xd:short>
        <xd:detail>
            <p>Strip all diacritics from a string, by first putting the string in the Unicode 'NFKD' normalization form, and
            then removing all characters in the category diacritic mark.</p>
        </xd:detail>
    </xd:doc>

    <xsl:function name="f:strip-diacritics" as="xs:string">
        <xsl:param name="string" as="xs:string"/>
        <xsl:value-of select="replace(normalize-unicode($string, 'NFKD'), '\p{M}', '')"/>
    </xsl:function>


    <xd:doc>
        <xd:short>Determine whether an element is rendered in the output.</xd:short>
        <xd:detail>
            <p>Determine whether an element is rendered in the output, based on the presence of <code>display(none)</code> in the <code>@rend</code>
            attribute of this element or one of its ancestors.</p>
        </xd:detail>
    </xd:doc>

    <xsl:function name="f:is-rendered" as="xs:boolean">
        <xsl:param name="node" as="node()"/>
        <xsl:sequence select="not($node/ancestor-or-self::*[f:rend-value(./@rend, 'display') = 'none'])"/>
    </xsl:function>


    <xd:doc>
        <xd:short>Determine whether an element is rendered inline in the output.</xd:short>
        <xd:detail>
            <p>Determine whether an element is rendered inline (that is, not as a block-level element) in the output, based on the presence of <code>position(inline)</code> in the <code>@rend</code>
            attribute of this element. Note that this only takes into account the <code>@rend</code> attribute, not the default value for <code>display</code> of an HTML element in the output.</p>
        </xd:detail>
    </xd:doc>


    <!-- TODO: deprecate use of 'position' for inline. -->

    <xsl:function name="f:is-inline" as="xs:boolean">
        <xsl:param name="node" as="element()"/>
        <xsl:sequence select="$node/@rend = 'inline' or f:rend-value($node/@rend, 'position') = 'inline' or f:rend-value($node/@rend, 'display') = 'inline'"/>
    </xsl:function>


    <xsl:function name="f:is-block" as="xs:boolean">
        <xsl:param name="node" as="element()"/>
        <xsl:sequence select="$node/@rend = 'block' or f:rend-value($node/@rend, 'display') = 'block' or f:has-class($node/@rend, 'block', 'q')"/>
    </xsl:function>


    <!-- hidden: not visible, but takes up space. If an ancestor is hidden, we are hidden as well. -->

    <xsl:function name="f:is-hidden" as="xs:boolean">
        <xsl:param name="node" as="element()"/>
        <xsl:sequence select="exists($node/ancestor-or-self::*[f:rend-value(./@rend, 'visibility') = 'hidden'])"/>
    </xsl:function>


    <!-- not-displayed: not visible and not taking up space. If an ancestor is not displayed, we are not displayed as well.  -->
    <!-- Sometimes content marked as hidden is still displayed via the align-with rend attribute! -->

    <xsl:function name="f:is-not-displayed" as="xs:boolean">
        <xsl:param name="node" as="element()"/>
        <xsl:sequence select="exists($node/ancestor-or-self::*[f:rend-value(./@rend, 'display') = 'none' and not(f:used-in-align-with(.))])"/>
    </xsl:function>

    <xsl:function name="f:used-in-align-with" as="xs:boolean">
        <xsl:param name="node" as="element()"/>
        <xsl:sequence select="exists($root//*[f:rend-value(./@rend, 'align-with') = $node/@id])"/>
    </xsl:function>

    <xsl:function name="f:is-pdf" as="xs:boolean">
        <xsl:sequence select="$optionPrinceMarkup = 'Yes'"/>
    </xsl:function>

    <xsl:function name="f:is-epub" as="xs:boolean">
        <xsl:sequence select="$outputFormat = 'epub'"/>
    </xsl:function>

    <xsl:function name="f:is-html" as="xs:boolean">
        <xsl:sequence select="$outputFormat = ('html', 'html5', 'xhtml', 'xhtml5')"/>
    </xsl:function>

    <xsl:function name="f:is-html5" as="xs:boolean">
        <xsl:sequence select="$outputFormat = ('html5', 'xhtml5')"/>
    </xsl:function>

    <xd:doc>
        <xd:short>Classify the content of an element.</xd:short>
        <xd:detail>
            <p>Try to classify the content of an element, based on a regular expression. This will be used to set a class-attribute on the generated HTML element. The following types will be recognized:</p>

            <table>
                <tr><th>Type        </th><th>Code       </th><th>Description </th></tr>

                <tr><td>Empty       </td><td>ccEmpty    </td><td>Empty or nearly empty (whitespace only)</td></tr>
                <tr><td>Dash        </td><td>ccDash     </td><td>Dash, ellipsis or other marker that indicates no value is available</td></tr>
                <tr><td>Numeric     </td><td>ccNum      </td><td>Numeric value</td></tr>
                <tr><td>Percentage  </td><td>ccPct      </td><td>Percentage (i.e., followed by a percent sign)</td></tr>
                <tr><td>Amount      </td><td>ccAmt      </td><td>Monetary amount (i.e., preceded or followed by a currency sign)</td></tr>
                <tr><td>Text        </td><td>ccTxt      </td><td>Alpha-numeric content, not being one of the above.</td></tr>
                <!--
                <tr><td>Date        </td><td>ccDate     </td><td>A calendar date</td></tr>
                <tr><td>Time        </td><td>ccTime     </td><td>A time</td></tr>
                <tr><td>Date + Time </td><td>ccDttm     </td><td>A date and time</td></tr>
                -->
                <tr><td>Other       </td><td>ccOther    </td><td>Anything else.</td></tr>
            </table>

            <p>The content of (embedded) notes will be ignored. If the element already has a <code>@rend</code> attribute with a relevant type, an empty string will be returned.</p>
        </xd:detail>
    </xd:doc>

    <xsl:function name="f:classify-content" as="xs:string">
        <xsl:param name="node" as="element()"/>

        <!-- flatten content and strip notes -->
        <xsl:variable name="string">
            <xsl:apply-templates select="$node" mode="flatten-textual-content"/>
        </xsl:variable>
        <xsl:variable name="string" select="string-join($string)"/>
        <xsl:variable name="string" select="normalize-space($string)"/>

        <xsl:sequence select="if (f:has-content-classification($node))  then ''
            else if (not($string) or $string = '')                      then 'ccEmpty'
            else if (f:is-dash-like($string))                           then 'ccDash'
            else if (f:is-unicode-number($string))                      then 'ccNum'
            else if (f:is-unicode-percentage($string))                  then 'ccPct'
            else if (f:is-unicode-amount($string))                      then 'ccAmt'
            else if (f:is-unicode-text($string))                        then 'ccTxt'
            else 'ccOther'"/>
    </xsl:function>

    <xsl:function name="f:has-content-classification" as="xs:boolean">
        <xsl:param name="node" as="element()"/>

        <xsl:variable name="name" select="name($node)"/>

        <xsl:sequence select="
               f:has-class($node/@rend, 'alignDecimalIntegerPart', $name)
            or f:has-class($node/@rend, 'alignDecimalFractionPart', $name)
            or f:has-class($node/@rend, 'ccEmpty', $name)
            or f:has-class($node/@rend, 'ccDash', $name)
            or f:has-class($node/@rend, 'ccNum', $name)
            or f:has-class($node/@rend, 'ccPct', $name)
            or f:has-class($node/@rend, 'ccAmt', $name)
            or f:has-class($node/@rend, 'ccTxt', $name)
            or f:has-class($node/@rend, 'ccOther', $name)
            "/>
    </xsl:function>


    <xsl:template match="note" mode="flatten-textual-content"/>

    <xsl:template match="choice[corr]" mode="flatten-textual-content">
        <xsl:apply-templates select="corr" mode="flatten-textual-content"/>
    </xsl:template>

    <xsl:template match="seg[@copyOf]" mode="flatten-textual-content">
        <xsl:apply-templates select="//*[@id = current()/@copyOf]" mode="flatten-textual-content"/>
    </xsl:template>


    <xsl:variable name="unicode-number-pattern" select="'^\s?(((\p{Nd}+[.,])*\p{Nd}+)(([.,]\p{Nd}+)?(\p{No})?)|(\p{No})|([.,]\p{Nd}+))\s?$'"/>
    <xsl:variable name="unicode-percentage-pattern" select="'^\s?(((\p{Nd}+[.,])*\p{Nd}+)(([.,]\p{Nd}+)?(\p{No})?)|(\p{No})|([.,]\p{Nd}+))\s*[%&#x2030;&#x2031;&#x066A;&#xFF05;&#xFE6A;]\s?$'"/>
    <xsl:variable name="unicode-amount-pattern-1" select="'^\s*\p{Sc}\s*(((\p{Nd}+[.,])*\p{Nd}+)(([.,]\p{Nd}+)?(\p{No})?)|(\p{No})|([.,]\p{Nd}+))\s*$'"/>
    <xsl:variable name="unicode-amount-pattern-2" select="'^\s*(((\p{Nd}+[.,])*\p{Nd}+)(([.,]\p{Nd}+)?(\p{No})?)|(\p{No})|([.,]\p{Nd}+))\s*\p{Sc}\s*$'"/>

    <xsl:function name="f:is-unicode-number" as="xs:boolean">
        <xsl:param name="string"/>
        <xsl:sequence select="matches(string($string), $unicode-number-pattern, 'i')"/>
    </xsl:function>

    <xsl:function name="f:is-unicode-percentage" as="xs:boolean">
        <xsl:param name="string"/>
        <xsl:sequence select="matches(string($string), $unicode-percentage-pattern, 'i')"/>
    </xsl:function>

    <xsl:function name="f:is-unicode-amount" as="xs:boolean">
        <xsl:param name="string"/>
        <xsl:sequence select="matches(string($string), $unicode-amount-pattern-1, 'i')
                           or matches(string($string), $unicode-amount-pattern-2, 'i')"/>
    </xsl:function>

    <xsl:function name="f:is-unicode-text" as="xs:boolean">
        <xsl:param name="string"/>
        <xsl:sequence select="matches(string($string), '\p{L}+', 'i')"/>
    </xsl:function>

    <xsl:function name="f:is-dash-like" as="xs:boolean">
        <xsl:param name="string"/>
        <xsl:sequence select="matches(string($string), '^([&mdash;&ndash;&hellip;-]|(\.\.\.+))$', 'i')"/>
    </xsl:function>

</xsl:stylesheet>
